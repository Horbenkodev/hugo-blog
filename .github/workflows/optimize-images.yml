name: Optimize Images

# Run when images are added/modified
on:
  pull_request:
    paths:
      - 'content/posts/**/*.jpg'
      - 'content/posts/**/*.jpeg'
      - 'content/posts/**/*.png'
      - 'content/posts/**/*.gif'
      - 'static/img/**/*.jpg'
      - 'static/img/**/*.jpeg'
      - 'static/img/**/*.png'
      - 'static/img/**/*.gif'
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write  # Only what's needed for git push

jobs:
  optimize:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'decap-cms/pending_publish')
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install optimization tools
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick webp jpegoptim optipng pngquant

      - name: Optimize images in-place
        run: |
          set -euo pipefail

          echo "üéØ Starting image optimization..."
          echo "Current images size:"
          du -sh content/posts/ 2>/dev/null || echo "No content/posts directory"
          du -sh static/img/ 2>/dev/null || echo "No static/img directory"

          # Use files for counters to avoid subshell issues
          echo "0" > /tmp/optimized_count
          echo "0" > /tmp/total_count

          # Process both directories
          DIRS="content/posts static/img"

          # Optimize JPEGs
          while IFS= read -r img; do
            [ -z "$img" ] && continue
            echo $(($(cat /tmp/total_count) + 1)) > /tmp/total_count
            original_size=$(stat -c%s "$img")

            # Optimize with jpegoptim (quality 80%)
            jpegoptim --max=80 --strip-all --preserve --quiet "$img" || true

            new_size=$(stat -c%s "$img")
            if [ "$new_size" -lt "$original_size" ]; then
              echo $(($(cat /tmp/optimized_count) + 1)) > /tmp/optimized_count
              saved=$((original_size - new_size))
              echo "‚úÖ Optimized: $img (saved $(numfmt --to=iec $saved))"
            fi
          done < <(find $DIRS -type f \( -name "*.jpg" -o -name "*.jpeg" \) 2>/dev/null)

          # Optimize PNGs
          while IFS= read -r img; do
            [ -z "$img" ] && continue
            echo $(($(cat /tmp/total_count) + 1)) > /tmp/total_count
            original_size=$(stat -c%s "$img")

            # Try pngquant first (lossy but better compression)
            # pngquant exits with code 98 when the result would be larger; under set -e that would fail the job.
            # Make it non-fatal and decide based on the existence of the tmp file.
            pngquant --quality=80-95 --skip-if-larger --strip --force --output "$img.tmp" "$img" 2>/dev/null || true

            if [ -f "$img.tmp" ]; then
              mv "$img.tmp" "$img"
              echo $(($(cat /tmp/optimized_count) + 1)) > /tmp/optimized_count
              new_size=$(stat -c%s "$img")
              saved=$((original_size - new_size))
              echo "‚úÖ Optimized: $img (saved $(numfmt --to=iec $saved))"
            else
              # Fallback to optipng (lossless)
              optipng -quiet -o2 -preserve "$img" || true
            fi
          done < <(find $DIRS -type f -name "*.png" 2>/dev/null)

          # Resize very large images (>2MB or >2000px)
          while IFS= read -r img; do
            [ -z "$img" ] && continue
            # Check file size
            size=$(stat -c%s "$img")
            if [ "$size" -gt 2097152 ]; then  # 2MB in bytes
              echo "üìê Resizing large image: $img ($(numfmt --to=iec $size))"
              convert "$img" -resize "2000x2000>" -quality 80 "$img" || true
            fi
          done < <(find $DIRS -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" \) 2>/dev/null)

          echo ""
          echo "‚ú® Optimization complete!"
          echo "Optimized $(cat /tmp/optimized_count) out of $(cat /tmp/total_count) images"
          echo "New images size:"
          du -sh content/posts/ 2>/dev/null || echo "No content/posts directory"
          du -sh static/img/ 2>/dev/null || echo "No static/img directory"

      - name: Show optimization results
        run: |
          # Count images in both directories
          DIRS="content/posts static/img"
          jpg_count=$(find $DIRS -type f \( -name "*.jpg" -o -name "*.jpeg" \) 2>/dev/null | wc -l)
          png_count=$(find $DIRS -type f -name "*.png" 2>/dev/null | wc -l)

          echo "üìä Image Statistics:"
          echo "- JPEG images: $jpg_count"
          echo "- PNG images: $png_count"
          echo "- Total images: $((jpg_count + png_count))"

          # Show largest images
          echo ""
          echo "üèÜ Largest images after optimization:"
          find $DIRS -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" \) 2>/dev/null -exec ls -lh {} \; | sort -k5 -rh | head -10

      - name: Commit optimized images
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Check if there are changes in either directory
          if [ -n "$(git status --porcelain content/posts/ static/img/ 2>/dev/null)" ]; then
            # Add all image files from both directories
            git add content/posts/ static/img/ 2>/dev/null || true
            git reset -- '*.md' 2>/dev/null || true  # Don't add markdown files

            git commit -m "üñºÔ∏è Optimize images for faster builds

            Automated image optimization:
            - Reduced JPEG quality to 80%
            - Optimized PNG compression
            - Resized images larger than 2000px

            [skip ci]"

            echo "‚úÖ Changes committed and pushed!"
          else
            echo "‚ÑπÔ∏è No changes to commit - images are already optimized"
          fi

      - name: Auto Merge Pull Request
        uses: pascalgn/automerge-action@v0.16.0 # Or another suitable auto-merge action
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Configuration for the auto-merge action (e.g., merge strategy, required status checks)
          merge_method: squash # or merge, rebase
          # required_statuses: 'build, test' # Example of required status checks

      - name: Merge into Main
        run: |
          git rebase origin/main
          git push origin main
